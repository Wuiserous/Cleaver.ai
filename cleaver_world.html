
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cleaver World 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: white; pointer-events: none; text-shadow: 1px 1px 2px black;
        }
        #controls {
            position: absolute; bottom: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>CLEAVER WORLD</h1>
        <p>Click on a Cleaver to see it react!</p>
    </div>
    <div id="controls">
        Orbit: Left Click | Zoom: Scroll | Pan: Right Click
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, raycaster, mouse;
        let cleavers = [];
        const worldSize = 20;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x7cfc00 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Chores/Points of Interest
            createPOI(5, 0, 5, 0xff0000, "Wood Pile");
            createPOI(-5, 0, -5, 0x0000ff, "Water Well");
            createPOI(5, 0, -5, 0xffff00, "Garden");

            // Create Cleavers
            for(let i = 0; i < 8; i++) {
                createCleaver();
            }

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function createPOI(x, y, z, color, label) {
            const geo = new THREE.BoxGeometry(1, 0.5, 1);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.25, z);
            mesh.castShadow = true;
            scene.add(mesh);
        }

        function createCleaver() {
            const group = new THREE.Group();

            // Blade
            const bladeGeo = new THREE.BoxGeometry(0.6, 0.4, 0.05);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.5;
            blade.castShadow = true;
            group.add(blade);

            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.set(-0.3, 0.3, 0);
            handle.rotation.z = Math.PI / 4;
            handle.castShadow = true;
            group.add(handle);

            group.position.set(
                (Math.random() - 0.5) * worldSize,
                0,
                (Math.random() - 0.5) * worldSize
            );

            const cleaverData = {
                mesh: group,
                target: new THREE.Vector3(),
                state: 'walking',
                timer: 0,
                speed: 0.02 + Math.random() * 0.03,
                reaction: 0
            };
            
            setNewTarget(cleaverData);
            scene.add(group);
            cleavers.push(cleaverData);
        }

        function setNewTarget(c) {
            c.target.set(
                (Math.random() - 0.5) * worldSize,
                0,
                (Math.random() - 0.5) * worldSize
            );
            c.mesh.lookAt(c.target.x, 0, c.target.z);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            for (let i = 0; i < intersects.length; i++) {
                let obj = intersects[i].object;
                while(obj.parent && !obj.isCleaver) {
                    if(cleavers.find(c => c.mesh === obj)) {
                        const cleaver = cleavers.find(c => c.mesh === obj);
                        react(cleaver);
                        return;
                    }
                    obj = obj.parent;
                }
            }
        }

        function react(c) {
            c.reaction = 1.0;
            c.state = 'reacting';
            c.timer = 60;
            // Jump effect
            c.mesh.position.y = 1;
            setTimeout(() => { c.mesh.position.y = 0; c.state = 'walking'; }, 500);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            cleavers.forEach(c => {
                if (c.state === 'walking') {
                    c.mesh.position.lerp(c.target, c.speed);
                    // Waddle animation
                    c.mesh.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                    
                    if (c.mesh.position.distanceTo(c.target) < 0.5) {
                        c.state = 'chore';
                        c.timer = 100 + Math.random() * 200;
                    }
                } else if (c.state === 'chore') {
                    // Chore animation (spinning or bobbing)
                    c.mesh.rotation.y += 0.05;
                    c.timer--;
                    if (c.timer <= 0) {
                        c.state = 'walking';
                        setNewTarget(c);
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
