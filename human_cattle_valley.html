
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Human & Cattle Valley 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: white; pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #controls {
            position: absolute; bottom: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>HUMAN & CATTLE VALLEY</h1>
        <p>A bustling 3D ecosystem. Click any living being to interact.</p>
    </div>
    <div id="controls">
        <b>CONTROLS</b><br>
        Orbit: Left Click | Zoom: Scroll | Pan: Right Click
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, raycaster, mouse;
        let entities = []; // Store humans and cattle
        const worldSize = 80;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 40, 180);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.enableDamping = true;
            
            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 150, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            scene.add(sunLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(400, 400);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x3a5f25, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createEnvironment();
            
            // Populate World
            for(let i = 0; i < 12; i++) createCow();
            for(let i = 0; i < 8; i++) createHuman();
            for(let i = 0; i < 5; i++) createCart((Math.random()-0.5)*60, (Math.random()-0.5)*60);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createEnvironment() {
            // River
            const riverGeo = new THREE.PlaneGeometry(25, 400);
            const riverMat = new THREE.MeshStandardMaterial({ color: 0x0077be, transparent: true, opacity: 0.7, metalness: 0.9, roughness: 0.1 });
            const river = new THREE.Mesh(riverGeo, riverMat);
            river.rotation.x = -Math.PI / 2;
            river.position.set(-70, 0.05, 0);
            scene.add(river);

            // Mountains
            const mtMat = new THREE.MeshStandardMaterial({ color: 0x3d3d3d, roughness: 1.0 });
            for(let i = 0; i < 25; i++) {
                const h = 30 + Math.random() * 50;
                const mt = new THREE.Mesh(new THREE.ConeGeometry(25, h, 6), mtMat);
                const angle = (i / 25) * Math.PI * 2;
                mt.position.set(Math.cos(angle) * 150, h/2 - 2, Math.sin(angle) * 150);
                scene.add(mt);
            }

            // Village
            for(let i = 0; i < 10; i++) createHouse((Math.random()-0.5)*80, (Math.random()-0.5)*80);
            for(let i = 0; i < 100; i++) createTree((Math.random()-0.5)*200, (Math.random()-0.5)*200);
        }

        function createHouse(x, z) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(6, 5, 6), new THREE.MeshStandardMaterial({ color: 0x7d5a44 }));
            base.position.y = 2.5; base.castShadow = true; group.add(base);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(5.5, 4, 4), new THREE.MeshStandardMaterial({ color: 0x331a00 }));
            roof.position.y = 7; roof.rotation.y = Math.PI/4; roof.castShadow = true; group.add(roof);
            group.position.set(x, 0, z); scene.add(group);
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 5), new THREE.MeshStandardMaterial({ color: 0x2b1d0e }));
            trunk.position.y = 2.5; group.add(trunk);
            const leaves = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), new THREE.MeshStandardMaterial({ color: 0x0b3d1a }));
            leaves.position.y = 6; leaves.castShadow = true; group.add(leaves);
            group.position.set(x, 0, z); group.scale.setScalar(0.7 + Math.random()); scene.add(group);
        }

        function createCart(x, z) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
            
            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.4, 5), woodMat);
            base.position.y = 1.2; base.castShadow = true; group.add(base);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            for(let i=0; i<4; i++) {
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.rotation.z = Math.PI/2;
                w.position.set(i<2?1.6:-1.6, 0.8, i%2==0?1.8:-1.8);
                w.castShadow = true; group.add(w);
            }
            
            // Handle
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3), woodMat);
            handle.rotation.x = Math.PI/2;
            handle.position.set(0, 1.2, 3.5);
            group.add(handle);

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            scene.add(group);
        }

        function createHuman() {
            const group = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const clothMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.4), clothMat);
            torso.position.y = 1.8; torso.castShadow = true; group.add(torso);

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), skinMat);
            head.position.y = 2.6; head.castShadow = true; group.add(head);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.2);
            const legL = new THREE.Mesh(legGeo, clothMat); legL.position.set(0.2, 0.6, 0); group.add(legL);
            const legR = new THREE.Mesh(legGeo, clothMat); legR.position.set(-0.2, 0.6, 0); group.add(legR);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.0);
            const armL = new THREE.Mesh(armGeo, skinMat); armL.position.set(0.45, 1.8, 0); group.add(armL);
            const armR = new THREE.Mesh(armGeo, skinMat); armR.position.set(-0.45, 1.8, 0); group.add(armR);

            group.position.set((Math.random()-0.5)*100, 0, (Math.random()-0.5)*100);
            
            const data = {
                mesh: group,
                target: new THREE.Vector3(),
                speed: 0.03 + Math.random() * 0.04,
                type: 'human'
            };
            setNewTarget(data);
            scene.add(group);
            entities.push(data);
        }

        function createCow() {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const spotMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2), bodyMat);
            body.position.y = 1.2; body.castShadow = true; group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.8), bodyMat);
            head.position.set(0, 1.6, 1.2); group.add(head);
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.3), new THREE.MeshStandardMaterial({color: 0xffc0cb}));
            snout.position.set(0, 1.5, 1.7); group.add(snout);

            for(let i=0; i<4; i++) {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8), bodyMat);
                leg.position.set(i<2?0.4:-0.4, 0.4, i%2==0?0.7:-0.7);
                group.add(leg);
            }

            group.position.set((Math.random()-0.5)*120, 0, (Math.random()-0.5)*120);
            const data = {
                mesh: group,
                target: new THREE.Vector3(),
                speed: 0.01 + Math.random() * 0.02,
                type: 'cow'
            };
            setNewTarget(data);
            scene.add(group);
            entities.push(data);
        }

        function setNewTarget(e) {
            e.target.set((Math.random()-0.5)*140, 0, (Math.random()-0.5)*140);
            e.mesh.lookAt(e.target.x, 0, e.target.z);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            for (let i = 0; i < intersects.length; i++) {
                let obj = intersects[i].object;
                while(obj.parent) {
                    const e = entities.find(ent => ent.mesh === obj);
                    if(e) { react(e); return; }
                    obj = obj.parent;
                }
            }
        }

        function react(e) {
            const startY = e.mesh.position.y;
            let start = Date.now();
            const jump = () => {
                let time = (Date.now() - start) / 500;
                if(time < 1) {
                    e.mesh.position.y = startY + Math.sin(time * Math.PI) * 4;
                    e.mesh.rotation.y += 0.3;
                    requestAnimationFrame(jump);
                } else {
                    e.mesh.position.y = startY;
                    setNewTarget(e);
                }
            };
            jump();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            entities.forEach(e => {
                e.mesh.position.lerp(e.target, e.speed * 0.05);
                // Walking animation
                if(e.type === 'human') {
                    e.mesh.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                } else {
                    e.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.15;
                }
                if(e.mesh.position.distanceTo(e.target) < 2) setNewTarget(e);
            });
            controls.update();
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
